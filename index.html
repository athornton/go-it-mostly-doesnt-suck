<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Go: It Mostly Doesn't Suck</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="css/talk.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress"><div class="step" step="0" data-x="0" data-y="0"><h1 id="go-it-mostly-doesn-t-suck">Go: It Mostly Doesn't Suck</h1><h2 id="adam-thornton">Adam Thornton</h2><h2 id="speaking-as-a-private-individual">Speaking As A Private Individual</h2><p><a href="mailto:athornton@gmail.com">athornton@gmail.com</a></p></div><div class="step" step="1" data-x="1600" data-y="0"><h1 id="preliminaries">Preliminaries</h1><p>All software sucks.</p><p>I hope to convince you in the next few dozen minutes that Go sucks less than most software.</p><p>All hardware also sucks, and all users suck, too, but that's not what this talk is about.</p></div><div class="step" step="2" data-x="3200" data-y="0"><h1 id="tl-dr">tl;dr</h1><img src="images/Learn-Go.png" alt="" width="" height="400px"></img><p>Apologies to Randall Monroe</p><p><a href="https://xkcd.com/918/">https://xkcd.com/918/</a></p></div><div class="step" step="3" data-x="4800" data-y="0"><h1 id="you-can-leave-now">You Can Leave Now</h1><p>That was the important part.</p></div><div class="step" step="4" data-x="6400" data-y="0"><h1 id="yeah-but-what-does-that-even-mean">Yeah, But What Does That Even <em>Mean</em>?</h1><p>If Go feels like <strong>programming</strong>, then...</p><p>...C feels like programming naked,</p><p>...Python feels like programming with training wheels,</p><p>...Perl feels like unicycling naked,</p><p>...LISP feels like wielding an elegant weapon for a more civilized age,</p><p>...Java feels like programming while wearing mittens,</p><p>...COBOL feels like programming while wearing handcuffs and drunk in the back of a police cruiser,</p><p>...and PHP feels like punching yourself in the balls over and over.</p></div><div class="step" step="5" data-x="8000" data-y="0"><h1 id="a-slightly-less-pungent-version">A Slightly Less Pungent Version?</h1><p>Ways Go is like C (an incomplete list):</p><ul><li>Small: 25 keywords<ul><li>C:<ul><li>ANSI C: 32</li><li>C99: 36</li><li>C11: 45</li></ul></li><li>Java: 50</li><li>PHP: 67</li></ul></li><li>Go is statically typed.</li><li>Ken Thompson and Rob Pike wrote a lot of it.</li><li>It is fundamentally procedural.</li><li>Programming hipsters hate it.</li></ul></div><div class="step" step="6" data-x="9600" data-y="0"><h1 id="but-then-why-not-just-use-c">But then why not just use C?</h1><p>Things Go Does Better Than C (an incomplete list):</p><ul><li>No explicit memory management.</li><li>Much better type-safety.</li><li>Very rich set of standard libraries.</li><li>Import dependency management.</li><li>The range operator.</li><li>Interfaces.</li><li>Concurrency.</li><li>Native map type (you may know these as hashes, dicts, or associative arrays).</li><li>A 2006 view of what's cheap and expensive, not a 1975 view.</li></ul></div><div class="step" step="7" data-x="11200" data-y="0"><h1 id="enough-theory">Enough Theory</h1><h2 id="hello-world">Hello, World</h2><pre class="highlight code go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">"fmt"</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">)</span>
<span class="p">}</span></pre></div><div class="step" step="8" data-x="12800" data-y="0"><h1 id="line-by-line">Line-by-line</h1><pre class="highlight code go"><span class="kn">package</span> <span class="nx">main</span></pre><p>Select a package; "main" is used for commands.</p><pre class="highlight code go"><span class="kn">import</span> <span class="s">"fmt"</span></pre><p>Packages each have their own namespace; <tt>fmt</tt> is for text formatting.</p><pre class="highlight code go"><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span></pre><p>Just like in C, the primary entry point is called <tt>main()</tt>.  In Go, <tt>main()</tt> takes no arguments and returns nothing.</p><blockquote><ul><li>If you're wondering, <tt>os.Argv</tt> is where the rest of the command line lives.</li></ul></blockquote><pre class="highlight code go"><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">)</span></pre><p>Println comes from the <tt>fmt</tt> package.  It is capitalized (we'll see why later), and adds a newline to the end of its arguments.</p><pre class="highlight code go"><span class="p">}</span></pre><p>Closes the function (and ends the program).</p></div><div class="step" step="9" data-x="14400" data-y="0"><h1 id="packages">Packages</h1><p>Standard library is quite robust: math library (including complex and arbitrary precision numbers ), HTTP, regular expressions, JSON and XML encoding, 2D graphics....</p><p>No separate header files: the prologue of a Go binary package contains function names and their signatures.</p><p>Imports are done on a per-file basis.  That completely obviates the need for</p><pre class="highlight code c"><span class="cp">#ifndef _GONKULATOR_H
#define _GONKULATOR_H
</span><span class="cm">/* Code goes here */</span>
<span class="cp">#endif </span><span class="cm">/* gonkulator.h */</span></pre><p>...and unused imports are a fatal compile-time error.</p><ul><li>You will start off by cursing this.</li><li>Within a month you will wonder how you ever lived without it.</li></ul></div><div class="step" step="10" data-x="16000" data-y="0"><h1 id="packages-and-linkers-and-stuff">Packages and Linkers and Stuff</h1><h2 id="oh-my">Oh My</h2><p>Exported functions' names start with an uppercase letter.</p><ul><li>This is another thing that you will start off with "what kind of Mickey Mouse crap is this?" and within a month you will just accept it as a totally reasonable convention.</li></ul><p>Everything is statically linked.</p><ul><li>Well, kinda.  If you use cgo, you're linking to libc, and on OS X you have three system libraries.</li><li>No dependency hell.</li><li>Yes, executables are big; but disk space is cheap now and it's not like you have to move a 20MB file from place to place across a 300-baud modem link, right?</li><li>This does mean that if you are using a buggy library, you need to rebuild and redeploy.  Go works well in a rebuild-the-world sort of environment, and less well in a traditional patch-the-things setting.</li></ul></div><div class="step" step="11" data-x="17600" data-y="0"><h1 id="remote-imports">Remote Imports</h1><pre class="highlight code go"><span class="kn">import</span> <span class="p">(</span>
  <span class="s">"github.com/gonkulator/libkv/store"</span>
<span class="p">)</span></pre><p>The dependency fetcher (<tt>go get</tt>) is smart enough to know that github uses git.  It knows about Bitbucket, GitHub, <span class="strike">Google Code Project Hosting</span>, Launchpad, and IBM DevOps Services.</p><p>You can also define private repositories, using any of Bazaar, Git, Mercurial, or Subversion.</p><ul><li>If you're still using CVS, may God have mercy on your soul.</li></ul></div><div class="step" step="12" data-x="19200" data-y="0"><h1 id="namespace-collisions">Namespace Collisions</h1><pre class="highlight code go"><span class="kn">import</span> <span class="p">(</span>
  <span class="s">"crypto/tls"</span>
  <span class="nx">aztls</span> <span class="s">"github.com/Azure/azure-sdk-for-go/core/tls"</span>
<span class="p">)</span></pre><p>Refer to the standard TLS package as "tls" and Azure's as "aztls".</p><p>Package functions are always referred to as package dot function.  So you're free to have both:</p><pre class="highlight ">math.Tan()
salon.Tan()</pre><ul><li>So you can't have the case where you call <tt>Tan()</tt> and it runs the one from the <tt>salon</tt> package when you thought you were calling the <tt>math</tt> one.</li><li>Or <tt>redefinition of 'Tan'</tt>.</li><li>Since all dependencies are explicit and done at the file level, you also can't get into the situation where the app depends on version <tt>1.2.16</tt> of <tt>log4j</tt>, but one of its other dependencies imported version <tt>1.2.11</tt> before your import happened.  Not that this has ever happened anywhere I ever worked.</li></ul></div><div class="step" step="13" data-x="20800" data-y="0"><h1 id="dependency-versioning">Dependency Versioning</h1><p>This is one of the things you're going to hear programming hipsters hate on Go about.  They have a point.</p><p><tt>godep</tt> is pretty dreadful, actually.</p><p>I haven't used <tt>glide</tt>.</p><p>The <tt>GO15VENDOREXPERIMENT</tt> didn't really work.  Not all experiments do.</p><p><tt>gopkg.in</tt> is amusing.  It uses git tag conventions to redirect an import of <tt>gopkg.in/user/pkg.v3</tt> to <tt>github.com/user/pkg</tt> with tag <tt>v3</tt> or tag <tt>v3.x</tt> or <tt>v3.x.y</tt>.  That's still pretty hinky and ad-hoc, though.</p><p>But anyone who insists super-stridently about this is blowing smoke and concern trolling you anyway.  It's definitely Not That Terrible.</p></div><div class="step" step="14" data-x="22400" data-y="0"><h1 id="things-you-will-miss">Things You Will Miss</h1><p>No REPL loop.</p><ul><li>You can use the Playground at golang.org, or set up your own playground, but it isn't the same.</li><li>On the other hand, building is really quite fast, and "go run" comes close.  It's still not really having a REPL loop.</li></ul><p>No optional arguments.</p><ul><li>Pointer arguments, and <tt>nil</tt> acting as "no argument," is the common idiom, but feels gross.</li></ul></div><div class="step" step="15" data-x="24000" data-y="0"><h1 id="things-you-might-miss">Things You Might Miss</h1><p>Generics.</p><ul><li>Go isn't Java.  Or C++.</li><li><tt>go generate</tt> actually lets you build a regex-based generics system, if you insist.</li></ul><p>Preprocessor macros.</p><ul><li>Function calls are pretty fast these days; it isn't 1978 anymore.</li><li><tt>go generate</tt> actually lets you build a preprocessor macro expansion system, if you insist.</li></ul></div><div class="step" step="16" data-x="25600" data-y="0"><h1 id="things-you-won-t-miss">Things You Won't Miss</h1><p>C:</p><blockquote><ul><li>Pointer arithmetic.</li><li><tt>malloc()</tt>, <tt>free()</tt>.</li><li><tt>#ifdef</tt> guards.</li></ul></blockquote><p>Java:</p><blockquote><ul><li>FactoryDBConnectorFactoryAbstractFactoryImplementorFactorySetterFactoryGeneratorFactory()</li><li>Working in a language that Oracle only resentfully supports.</li></ul><blockquote><ul><li>P.S. Larry Ellison hates you.</li></ul></blockquote></blockquote><p>PHP:</p><blockquote><ul><li>Everything.</li></ul></blockquote></div><div class="step" step="17" data-x="27200" data-y="0"><h1 id="the-best-thing-about-go">The Best Thing About Go</h1><p>I'm not sure how to define this crisply, but:</p><p>In Go, the gap between having a program that compiles and a program that does what I want it to is consistently much smaller than it is in any other language I've used, and I've used a lot of languages.</p></div><div class="step" step="18" data-x="28800" data-y="0"><h1 id="if-you-re-not-a-programmer-yet-but-would-like-to-learn">If You're Not A Programmer Yet But Would Like To Learn</h1><p>I think Go would be a pretty good first language.</p><p>It would be an even better second language.  Python is more approachable and forgiving.  But when you're ready to take the training wheels off, here are some nice features.  They should look familiar:</p><ul><li>Built-in maps.</li></ul><blockquote><ul><li>Other languages may call these things hashes, dicts, or associative arrays.  Whatever you call them, they're wonderfully useful.</li></ul></blockquote><ul><li>Small number of keywords and sane syntax makes it easy to keep in your head, and you can probably read other people's Go (I'm looking at <em>you</em>, Perl).</li></ul></div><div class="step" step="19" data-x="30400" data-y="0"><h1 id="basically-imperative">Basically Imperative</h1><ul><li>Go doesn't try to cram functional programming down your neck when you're still getting the hang of imperative programming (I'm looking at <em>you</em>, Javascript).</li><li>Object orientation and concurrency are mostly orthogonal to the rest of the language, although somehow without feeling bolted-on the way they do in, say, Perl.</li></ul><blockquote><ul><li>You can learn them when you're ready.</li><li>You can still write perfectly reasonable and idiomatic programs without them first.</li></ul></blockquote></div><div class="step" step="20" data-x="32000" data-y="0"><h1 id="also-nice-for-the-novice">Also Nice For The Novice</h1><p>The built-in github-friendliness and autogeneration of documentation helps to create a particular culture around Go code that is made public.</p><ul><li>That culture values lucid and concise over either:</li></ul><blockquote><ul><li>clever and incomprehensible, or</li><li>prolix, repetitive, and boring.</li></ul></blockquote></div><div class="step" step="21" data-x="33600" data-y="0"><h1 id="unicode-support">Unicode Support</h1><p>There's a <tt>unicode</tt> package.</p><p>Strings are Unicode already.  But really they're byte arrays.</p><p>Mostly it just works.  At least I haven't had to think about it much.</p></div><div class="step" step="22" data-x="35200" data-y="0"><h1 id="arrays-and-slices">Arrays and Slices</h1><p>Arrays have a specific fixed length.  Slices can grow and shrink.  Each one is sequential storage for elements of a particular type.</p><p>This is one of the confusing bits of Go, and it's hard to address in a short talk.  You get used to it pretty quickly.</p><p>Slices support indexing; the index intervals are half-open, like Python:</p><pre class="highlight code go"><span class="kn">import</span> <span class="s">"fmt"</span>
<span class="c1">//...
</span><span class="nx">l</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span><span class="s">"b"</span><span class="p">,</span><span class="s">"c"</span><span class="p">,</span><span class="s">"d"</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">"%v\n"</span><span class="p">,</span><span class="nx">l</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="c1">// [a b]
</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">"%v\n"</span><span class="p">,</span><span class="nx">l</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>  <span class="c1">// [a b]
</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">"%v\n"</span><span class="p">,</span><span class="nx">l</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span> <span class="c1">// [c d]
</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">"%v\n"</span><span class="p">,</span><span class="nx">l</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>  <span class="c1">// [c d]
</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">"%v\n"</span><span class="p">,</span><span class="nx">l</span><span class="p">[:])</span>   <span class="c1">// [a b c d]
// BUT:
// fmt.Printf("%v\n",[:-1]) yields ...
// invalid slice index -1 (index must be non-negative)
// Go isn't Python.
</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">"%v\n"</span><span class="p">,</span><span class="nx">l</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1">// [a b c]</span></pre></div><div class="step" step="23" data-x="36800" data-y="0"><h1 id="maps">Maps</h1><p>Maps: just like Perl hashes or Python dicts.</p><ul><li>The only tricky bit is that you have to allocate space for them first.</li></ul><pre class="highlight code go"><span class="kd">var</span> <span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
<span class="nx">m</span><span class="p">[</span><span class="s">"foo"</span><span class="p">]</span> <span class="p">=</span> <span class="s">"bar"</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">"%+v\n"</span><span class="p">,</span><span class="nx">m</span><span class="p">)</span></pre><ul><li>Yields <tt>panic: assignment to entry in nil map</tt></li><li>You need:</li></ul><pre class="highlight code go"><span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
<span class="nx">m</span><span class="p">[</span><span class="s">"foo"</span><span class="p">]</span> <span class="p">=</span> <span class="s">"bar"</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">"%+v\n"</span><span class="p">,</span><span class="nx">m</span><span class="p">)</span></pre><ul><li>Yields <tt>map[foo:bar]</tt></li></ul></div><div class="step" step="24" data-x="38400" data-y="0"><h1 id="more-about-maps">More About Maps</h1><p>A map key must be a comparable type.  A value can be any type.</p><ul><li>Comparable types:<ul><li>Boolean</li><li>Integer</li><li>Floating Point</li><li>Complex</li><li>String</li><li>Pointer</li><li>Channel</li><li>Interface</li><li>non-interface type X and interface T if X is comparable and X implements T</li><li>Structs if all fields are comparable</li><li>Arrays if values of the array type are comparable</li></ul></li><li>Non-comparable (except to nil):<ul><li>Slice</li><li>Map</li><li>Function</li></ul></li></ul><p>tl;dr sane map keys are going to work (and many insane keys).</p><blockquote><ul><li>See <a href="https://golang.org/ref/spec#Comparison_operators">https://golang.org/ref/spec#Comparison_operators</a></li></ul></blockquote></div><div class="step" step="25" data-x="40000" data-y="0"><h1 id="structs">Structs</h1><p>A lot like C.</p><pre class="highlight code go"><span class="kd">type</span> <span class="nx">Employee</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Firstname</span> <span class="kt">string</span>
    <span class="nx">Lastname</span>  <span class="kt">string</span>
    <span class="nx">Salary</span>    <span class="kt">float64</span> <span class="c1">// We have grand ambitions
</span>    <span class="nx">Title</span>     <span class="kt">string</span>
<span class="p">}</span></pre><p>Access fields with a dot.</p><pre class="highlight code go"><span class="kd">var</span> <span class="nx">e</span> <span class="nx">Employee</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Title</span><span class="p">=</span><span class="s">"Yes-Man, Third Class"</span></pre></div><div class="step" step="26" data-x="41600" data-y="0"><h1 id="embedded-structs">Embedded Structs</h1><p>Sort of like an inheritance-by-composition model.</p><pre class="highlight code go"><span class="kd">type</span> <span class="nx">Name</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Firstname</span> <span class="kt">string</span>
  <span class="nx">Lastname</span>  <span class="kt">string</span>
  <span class="nx">Middlename</span> <span class="kt">string</span>
  <span class="nx">Suffix</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">Employee</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Name</span>
  <span class="nx">Salary</span> <span class="kt">float64</span>
  <span class="nx">Title</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">e</span> <span class="nx">Employee</span></pre><p>You can still refer directly to <tt>e.Firstname</tt> (you can also say <tt>e.Name.Firstname</tt>)</p><p>(<a href="https://golang.org/doc/effective_go.html#embedding">https://golang.org/doc/effective_go.html#embedding</a>)</p></div><div class="step" step="27" data-x="43200" data-y="0"><h1 id="unit-testing">Unit Testing</h1><p>A little like Perl's test framework.</p><ul><li>It must have a filename of <tt>whatever_test.go</tt> in the same directory as <tt>whatever.go</tt>.</li><li>Usually should be in the same package as <tt>whatever</tt>, but sometimes it's handy to not do that; for example, if you want to only test exported functions.</li><li>Any function named <tt>TestXxx</tt>, where <tt>Xxx</tt> is any alphanumeric string that doesn't start with a lowercase letter, gets run.  The signature looks like <tt>func TestXxx(*testing.T)</tt>.</li><li>There are also <tt>BenchmarkXxx</tt> and <tt>ExampleXxx</tt> functions.</li></ul><p>Run it with <tt>go test</tt>.</p><p><a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a></p></div><div class="step" step="28" data-x="44800" data-y="0"><h1 id="a-little-tour-of-unusual-go-features">A Little Tour Of Unusual Go Features</h1><p>There are some things Go does that aren't much like C at all.  Here are a few:</p><ul><li>Multiple return values</li><li>Goroutines / Channels</li><li>Interfaces / Object Model</li><li><tt>defer</tt></li><li>Error handling / Exceptions</li></ul></div><div class="step" step="29" data-x="46400" data-y="0"><h1 id="multiple-return-values">Multiple Return Values</h1><p>This is most commonly seen as:</p><pre class="highlight code go"><span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
<span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
<span class="c1">// ...
</span><span class="k">if</span> <span class="nx">somethingWentWrong</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">""</span><span class="p">,</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">"something went wrong"</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">return</span> <span class="s">"bob's yer uncle"</span><span class="p">,</span> <span class="kc">nil</span></pre><p>But you are free to return multiple values of any type:</p><pre class="highlight code go"><span class="kd">func</span> <span class="nx">WeirdReturner</span><span class="p">(</span><span class="nx">f</span> <span class="kt">float</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">rune</span><span class="p">,</span> <span class="o">*</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">float</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span></pre></div><div class="step" step="30" data-x="48000" data-y="0"><h1 id="goroutines">Goroutines</h1><p>Go's concurrency support is in the runtime.  It uses things called goroutines (from "coroutines"), which are pretty much threads, but don't require OS support.</p><ul><li>Memory is shared, so you are responsible for doing your own mutex stuff (it's in the <tt>sync</tt> library).</li><li>You start a goroutine with: <tt>go RunSomething()</tt> or with an anonymous closure: <tt>go func() { ... }</tt></li><li>If you just want it to run, great, you're done (goroutines will exit when the main function exits).</li><li>For synchronization, you can use <tt>sync.Waitgroup</tt>, or use channels.</li><li>There is an excellent page on this at: <a href="https://divan.github.io/posts/go_concurrency_visualize/">https://divan.github.io/posts/go_concurrency_visualize/</a></li></ul></div><div class="step" step="31" data-x="49600" data-y="0"><h1 id="channels">Channels</h1><p>Go's channels are a synchronization mechanism.  A channel passes a particular type of value.</p><pre class="highlight code go"><span class="nx">i</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>        <span class="c1">// Unbuffered
</span><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1">// Capacity of three strings
</span><span class="nx">i</span> <span class="o">&lt;-</span> <span class="mi">1</span>                     <span class="c1">// Write to channel
</span><span class="nx">r</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">s</span>                   <span class="c1">// Read from channel</span></pre><p>Typically you'd use multiple channels in a <tt>select</tt> loop, which looks just like a <tt>select()</tt> loop in C or old-school Perl or whatever:</p><pre class="highlight code go"><span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">m</span> <span class="p">:</span><span class="o">&lt;-</span> <span class="nx">c1</span><span class="p">:</span>
            <span class="nx">HandleC1</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
        <span class="k">case</span> <span class="nx">m</span> <span class="p">:</span><span class="o">&lt;-</span> <span class="nx">c2</span><span class="p">:</span>
            <span class="nx">HandleC2</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
        <span class="c1">// ....
</span>    <span class="p">}</span>
<span class="p">}</span></pre><p>See <a href="https://talks.golang.org/2012/waza.slide">https://talks.golang.org/2012/waza.slide</a></p></div><div class="step" step="32" data-x="51200" data-y="0"><h1 id="interfaces">Interfaces</h1><p>This is how you get polymorphism in Go:</p><ul><li>A type supports particular methods.</li><li>An interface is a collection of methods.</li><li>Anything that supports all those methods therefore implements that interface.</li></ul></div><div class="step" step="33" data-x="52800" data-y="0"><h1 id="type-declaration">Type Declaration</h1><p>Most of the types you declare will probably be either array or struct types.  Like so:</p><pre class="highlight code go"><span class="kd">type</span> <span class="nx">Userlist</span> <span class="p">[]</span><span class="kt">string</span>
<span class="kd">type</span> <span class="nx">Employee</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Firstname</span> <span class="kt">string</span>
    <span class="nx">Lastname</span>  <span class="kt">string</span>
    <span class="nx">Salary</span>    <span class="kt">float64</span> <span class="c1">// We have grand ambitions
</span>    <span class="nx">Title</span>     <span class="kt">string</span>
<span class="p">}</span></pre></div><div class="step" step="34" data-x="54400" data-y="0"><h1 id="type-methods">Type Methods</h1><p>Look just like function definitions, except they have another parameter before the function name.</p><pre class="highlight code go"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Employee</span><span class="p">)</span> <span class="nx">ChangeTitle</span><span class="p">(</span><span class="nx">title</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="c1">// Needs to be a pointer to Employee because we are modifying it.
</span>    <span class="nx">oldtitle</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Title</span>
    <span class="nx">e</span><span class="p">.</span><span class="nx">Title</span> <span class="p">=</span> <span class="nx">title</span>
    <span class="k">return</span> <span class="nx">oldtitle</span>
<span class="p">}</span></pre></div><div class="step" step="35" data-x="56000" data-y="0"><h1 id="interface-definition">Interface Definition</h1><p>An interface is just a set of type methods that an object must provide.</p><pre class="highlight code go"><span class="kd">type</span> <span class="nx">Stringer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span></pre><p>The various fmt.Printf variations use an object's String() method, if it exists, to display the textual representation of an object.  If it doesn't have one, you just get the list of fields in order.  Let's add Stringer to Employee.</p></div><div class="step" step="36" data-x="57600" data-y="0"><h1 id="interface-definition-example">Interface Definition Example</h1><pre class="highlight code go"><span class="kn">import</span> <span class="s">"fmt"</span>
<span class="nx">e</span> <span class="o">:=</span> <span class="nx">Employee</span><span class="p">{</span>
    <span class="nx">Firstname</span><span class="p">:</span> <span class="s">"Edna"</span><span class="p">,</span>
    <span class="nx">Lastname</span><span class="p">:</span> <span class="s">"Schultz"</span><span class="p">,</span>
    <span class="nx">Title</span><span class="p">:</span> <span class="s">"Director of Something"</span><span class="p">,</span>
    <span class="nx">Salary</span><span class="p">:</span> <span class="mf">91532.20</span><span class="p">,</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"Employee: %v\n"</span><span class="p">,</span><span class="nx">e</span><span class="p">)</span></pre><p>Yields: <tt>Employee: {Edna Schultz 91532.2 Director of Something}</tt></p><p>That's ugly and we don't want to display the salary when we print the object.  So let's add a <tt>String()</tt> method:</p><pre class="highlight code go"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="nx">Employee</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Lastname</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Firstname</span> <span class="o">+</span> <span class="s">" ["</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Title</span> <span class="o">+</span> <span class="s">"]"</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span></pre><p>Now we get <tt>Employee: Schultz, Edna [Director of Something]</tt>, which looks a lot better.</p></div><div class="step" step="37" data-x="59200" data-y="0"><h1 id="defer"><tt>defer</tt></h1><p><tt>defer</tt> is the best thing since sliced bread.</p><p>When you <tt>defer</tt> a function, you are saying: when you exit this function, whether normally or via a <tt>panic()</tt> (we're getting to those next), run the deferred function.</p><ul><li><tt>defer</tt> statements are run in reverse order of declaration (that is, LIFO).</li><li>Arguments are evaluated when the <tt>defer</tt> statement is encountered.</li></ul><pre class="highlight code go"><span class="nx">bucket</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">couchbase</span><span class="p">.</span><span class="nx">GetBucket</span><span class="p">(</span><span class="nx">Bucketname</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// Complain, and then...
</span>    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="c1">// If we got here, we have a bucket.  We want to close it when we exit,
//  however we exit
</span><span class="k">defer</span> <span class="nx">bucket</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="c1">// ... do stuff with the bucket
</span><span class="k">return</span> <span class="kc">nil</span></pre><p>This makes it ever so much easier to remember to clean up resources when you're done with them.</p></div><div class="step" step="38" data-x="60800" data-y="0"><h1 id="errors-and-exceptions">Errors and Exceptions</h1><p>Go is not Java.  In general, you want to return an error, not throw an exception.</p><p>Functions can return multiple values, so a function signature that returns a result and an error is a very common idiom.</p><p>An error is a built-in type.</p><ul><li>As it happens, it's an interface type:</li></ul><pre class="highlight code go"><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span></pre><p>So you're free to define your own with more structure if you like (HTTP is a good example).</p></div><div class="step" step="39" data-x="62400" data-y="0"><h1 id="using-errors">Using Errors</h1><pre class="highlight code go"><span class="kn">import</span> <span class="s">"fmt"</span>
<span class="kd">func</span> <span class="nx">Scarborough</span><span class="p">(</span><span class="nx">arg</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="kt">string</span> <span class="p">{</span>
        <span class="k">case</span> <span class="s">"parsley"</span><span class="p">,</span> <span class="s">"sage"</span><span class="p">,</span> <span class="s">"rosemary"</span><span class="p">,</span> <span class="s">"thyme"</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">"ingredient '%s' not Simon-and-Garfunkel approved"</span><span class="p">,</span><span class="nx">arg</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></pre><p>Typical calling convention is:</p><pre class="highlight code go"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">Scarborough</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">"Guess *you're* not going to Scarborough Fair: %v"</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span></pre></div><div class="step" step="40" data-x="64000" data-y="0"><h1 id="exceptions">Exceptions</h1><p>Exceptions are <em>exceptional</em>.  Errors are not generally exceptional.</p><p><tt>panic(s)</tt></p><p>A <tt>panic</tt> in function <tt>F</tt> does the following:</p><ol><li>Stops execution of <tt>F</tt>.</li><li>Executes all of <tt>F</tt>'s deferred functions.</li><li>Returns to the caller of <tt>F</tt>.</li><li>Acts as if <tt>F</tt> had been a call to <tt>panic</tt>.</li></ol></div><div class="step" step="41" data-x="65600" data-y="0"><h1 id="recovering-from-panic">Recovering from Panic</h1><p><tt>recover</tt> only works inside a deferred function.  It catches the <tt>panic</tt> value (a string) and returns it.</p><p>If a <tt>panic</tt> reaches the top of a goroutine's call stack, the program exits and prints a stack trace.</p><p>The standard library package <tt>json</tt> contains a good example of this.</p><p>In general, you'd only recover a panic inside a library, because you generally want to return an error rather than destroy your caller's program.</p></div><div class="step" step="42" data-x="67200" data-y="0"><h1 id="some-random-language-nerd-things">Some Random Language Nerd Things</h1><p>Functions are first-class objects.</p><ul><li>This also makes dispatch tables really easy.</li></ul><p>You can use anonymous functions to make closures.</p><p>Go supports reflection, so you can do type introspection.</p><ul><li>The only time I've actually needed this in the wild was to get some non-exported fields out of an opaque data type, which I could safely do only because I understood the problem domain and knew that my private certificate would always really be an RSA certificate.</li><li>If you find yourself using <tt>reflect</tt> much, or the <tt>unsafe</tt> package, and you're not writing some sort of decoder/parser/unmarshaller thing, you are probably doing it wrong.</li></ul></div><div class="step" step="43" data-x="68800" data-y="0"><h1 id="editor-support">Editor Support</h1><p>There appears to be editor support for the major editors, by which I mean:</p><ul><li>Emacs (my choice)</li><li>Atom (my other choice)</li><li>Vim (if you swing that way)</li><li>Brackets (if you're a Web Design Hipster)</li><li>Eclipse (if you can't turn loose of Java)</li><li>Sublime (if you want something like Atom and hate saving money)</li><li>Nano/Pico/Joe/Gedit (if you don't like learning editors)</li><li>BBedit (if you have a Mac and hate saving money)</li><li>Visual Studio (what's wrong with you?)</li><li>Notepad++ (no, really, go see a doctor)</li><li>... (<a href="https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins">https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins</a>)</li></ul><p>I can vouch for Emacs and Atom.  For the most part Go support doesn't ship with the editor and you will have to install a plugin to get it.</p></div><div class="step" step="44" data-x="70400" data-y="0"><h1 id="code-style">Code Style</h1><p>Brilliant Gordian Knot solution.</p><ul><li>There's only one way to do it.</li><li><tt>go fmt</tt></li></ul><p>Set your editor to display tabs at a width you like, let the editor mode deal with it, and set up the environment to run <tt>go fmt</tt> on save.</p></div><div class="step" step="45" data-x="72000" data-y="0"><h1 id="godoc">Godoc</h1><p><a href="https://blog.golang.org/godoc-documenting-go-code">https://blog.golang.org/godoc-documenting-go-code</a></p><p>Basically, put a comment immediately before the function, with no intervening space, make sure that it starts with the name of the thing it's describing, and if it is on Bitbucket, GitHub, or Launchpad, then the first time anyone looks for it by import path, the documentation is autogenerated.</p></div><div class="step" step="46" data-x="73600" data-y="0"><h1 id="cute-logo">Cute Logo</h1><img src="images/gophercolor.png" alt="" width="" height="600px"></img><p>Gopher from golang.org, designed by Ren&#xE9;e French, licensed under Creative Commons Attribution 3.0 License.</p></div><div class="step" step="47" data-x="75200" data-y="0"><h1 id="oh-and-there-s-this">Oh, And There's This</h1><p>Google it as <tt>golang</tt> rather than <tt>go</tt> or you will be sad.</p></div><div class="step" step="48" data-x="76800" data-y="0"><h1 id="larger-example-depending-on-time">Larger Example, Depending On Time</h1><p>Let's write a thing.  Who wants to write a what?</p></div><div class="step" step="49" data-x="78400" data-y="0"><h1 id="this-talk">This Talk</h1><p><a href="https://github.com/athornton/go-it-mostly-doesnt-suck.git">https://github.com/athornton/go-it-mostly-doesnt-suck.git</a></p></div><div class="step" step="50" data-x="80000" data-y="0"><h1 id="questions">Questions?</h1><p>Not like I have answers.  But I'll do my best.</p><p>Adam Thornton</p><p><a href="mailto:athornton@gmail.com">athornton@gmail.com</a></p></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Left, Down, Page Down</th><td>Next slide</td></tr><tr><th>Right, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>